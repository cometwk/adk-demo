# fission-ai/openspec 实际案例分析

## 案例1：代理商分润结算功能 (agent-profit-settlement)

### 1.1 系统级规范 (System Specification)

**文件路径**: `openspec/specs/agent-profit-stats/spec.md`

**实际内容**:
```markdown
# Agent Profit Stats Specification

## Purpose
为代理商提供分润统计、查询和结算功能，支持按日统计分润数据并进行结算申请。

## 领域概念
- **分润表 (profit_daily)**: 按日统计每个代理商的分润数据
- **结算表 (profit_settle)**: 记录代理商的结算申请和审批状态
- **代理关系 (agent_rel)**: 定义代理商与商户/通道的绑定关系和费率

## Requirements
### Requirement: 分润计算必须基于代理关系
- **GIVEN** 代理商A通过agent_rel绑定商户M，费率P
- **WHEN** 商户M产生交易额T
- **THEN** 代理商A的分润 = T * P / 100000

### Requirement: 结算状态机管理
- **GIVEN** profit_daily记录状态为0（未结算）
- **WHEN** 代理商提交结算申请
- **THEN** 创建profit_settle记录，状态变为1（审批中）
- **AND WHEN** 审批通过
- **THEN** 状态变为2（已结算）
```

### 1.2 变更提案 (Change Proposal)

**文件路径**: `openspec/changes/agent-profit-settlement/proposal.md`

**实际内容**:
```markdown
# Change: agent-profit-settlement（代理商分润结算）

## Why
- 当前系统缺少完整的代理商分润结算功能，无法满足代理商对分润数据的查询和结算需求
- 需要支持按日统计分润，并提供结算申请和审批流程

## What Changes
- 新增 capability：`agent-profit-settlement`
- 新增数据表：`profit_daily`、`profit_settle`
- 新增 API 接口：
  - GET `/a/stats/profit-by-status` - 分润统计
  - POST `/a/profit/settle/apply` - 结算申请
  - POST `/a/profit/settle/:id/approve` - 审批结算

## Impact
- Affected specs: 新增 `agent-profit-stats`、`agent-profit-settle`
- Affected code/docs:
  - 路由：`serve/routes/bizadmin/agent/stats/*`
  - 数据模型：`serve/docs/ddl/profit_daily.sql`、`serve/docs/ddl/profit_settle.sql`
  - 任务：`serve/routes/tasks/profit/*`
```

### 1.3 技术设计 (Design Document)

**文件路径**: `openspec/changes/agent-profit-settlement/design.md`

**实际内容**:
```markdown
## Context
当前系统已有orders和refunds表存储交易数据，但缺少基于代理关系的分润计算和结算功能。

## Goals
- 实现T+1分润计算
- 支持代理商自助查询和结算申请
- 提供完整的审批流程

## Decisions
### Decision: 分润计算时机
- **选择**: 定时任务在闲时执行T+1分润计算
- **Why**: 不影响交易主链路性能，确保数据一致性

### Decision: 分润数据结构
- **选择**: 使用profit_daily表存储日分润数据
- **字段设计**:
  - `stat_date`: 统计日期（本地日）
  - `agent_no`: 代理商编号
  - `agent_type`: 代理类型（MERCH/CHAN）
  - `total_profit`: 总分润金额
  - `total_refund_deduct`: 退款扣除分润
  - `net_profit`: 净分润
  - `status`: 结算状态（0=未结算, 1=审批中, 2=已结算）

### Decision: 结算流程
- **选择**: 代理商提交结算申请 → 管理员审批 → 更新状态
- **Why**: 确保资金安全，防止恶意结算

## Implementation Plan
1. 创建profit_daily和profit_settle表
2. 实现分润计算定时任务
3. 开发代理商查询和结算API
4. 实现审批流程
```

### 1.4 任务清单 (Tasks)

**文件路径**: `openspec/changes/agent-profit-settlement/tasks.md`

**实际内容**:
```markdown
## 1. Implementation
- [x] 1.1 数据模型：创建profit_daily.sql和profit_settle.sql
- [x] 1.2 分润计算：实现SettleProfitDaily和RecalcProfitDaily函数
- [x] 1.3 API开发：
  - [x] 1.3.1 GET /a/stats/profit-by-status
  - [x] 1.3.2 POST /a/profit/settle/apply
  - [x] 1.3.3 POST /a/profit/settle/:id/approve
- [x] 1.4 定时任务：注册分润计算任务

## 2. Validation
- [x] 2.1 单元测试：分润计算逻辑
- [x] 2.2 集成测试：完整结算流程
- [x] 2.3 手动测试：代理商端操作验证
```

## 案例2：服务商SaaS API认证修复 (add-saas-api)

### 2.1 问题背景

在原有的服务商API认证实现中，存在一个严重的问题：
- 服务商请求头使用 `x-auth-saas-no`
- 但签名计算函数硬编码使用 `x-auth-merno`
- 导致验签失败，文档与实现不一致

### 2.2 变更提案

**文件路径**: `openspec/changes/add-saas-api/proposal.md`

**实际内容**:
```markdown
# Change: add-saas-api（服务商 SaaS API：认证与基础接口）

## Why
- 需要为 SaaS 服务商提供对外 HTTP 接口
- **服务商认证标识与签名字段名存在漂移**，需要通过 OpenSpec 明确最终约定

## What Changes
- **确定服务商对外认证标识（BREAKING）**：
  - 服务商对外认证标识 SHALL 使用 `saas_no`
- **对齐签名串字段名（BREAKING）**：
  - 请求头与签名串字段名 SHALL 使用 `x-auth-saas-no`

## Impact
- Affected specs: 新增 `saas-api`
- Affected code/docs:
  - 路由与中间件：`serve/routes/saasapi/*`
  - 签名计算工具：新增 `routes/hmac`
  - 文档：`serve/docs/api/saas-api-v1.md`
```

### 2.3 技术设计方案

**文件路径**: `openspec/changes/add-saas-api/design.md`

**实际内容**:
```markdown
## Decisions
### Decision: 签名计算函数设计
- **选择**: 支持"可配置的 auth header key 名称"
- **方案**:
  - 新增通用函数：`SHA256HexAuth(params, timestamp, authHeaderKeyName, authID, key)`
  - 为不同认证域提供封装函数：
    - `SHA256HexMerch(...)` → 使用 `x-auth-merno`
    - `SHA256HexSaas(...)` → 使用 `x-auth-saas-no`

### 代码实现
- 新增独立模块：`routes/hmac`
- 服务商侧认证切换为使用 `SHA256HexSaas(...)`
- 原有 merch 认证保持不动（避免扩大变更面）

## Migration Strategy
- 默认策略：按"BREAKING 变更"处理
- 兼容期内：服务端同时计算两种签名，任一匹配即通过
- 兼容开关：以配置控制是否启用兼容（默认关闭）
```

### 2.4 实际代码变更

**签名计算模块** (`serve/routes/hmac/hmac.go`):
```go
// SHA256HexAuth 通用签名函数
func SHA256HexAuth(params map[string]string, timestamp string, authHeaderKeyName string, authID string, key string) string {
    // 参数排序
    sortedParams := sortParams(params)
    // 拼接签名串：sortedParams + &x-timestamp=timestamp&authHeaderKeyName=authID&key=key
    signatureString := fmt.Sprintf("%s&x-timestamp=%s&%s=%s&key=%s", 
        sortedParams, timestamp, authHeaderKeyName, authID, key)
    return sha256Hex(signatureString)
}

// SHA256HexSaas 服务商专用封装
func SHA256HexSaas(params map[string]string, timestamp string, saasNo string, key string) string {
    return SHA256HexAuth(params, timestamp, "x-auth-saas-no", saasNo, key)
}
```

**认证中间件** (`serve/routes/saasapi/middleware.go`):
```go
// SaasAuthMiddleware 服务商认证中间件
func SaasAuthMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        saasNo := c.Request().Header.Get("x-auth-saas-no")
        timestamp := c.Request().Header.Get("x-timestamp")
        token := c.Request().Header.Get("x-auth-token")
        
        // 查询服务商
        saas, err := biz.SaasModel.GetBySaasNo(saasNo)
        if err != nil || saas == nil {
            return echo.NewHTTPError(http.StatusUnauthorized, "Invalid saas no")
        }
        
        // 验证签名
        params := extractParams(c)
        expectedToken := hmac.SHA256HexSaas(params, timestamp, saasNo, saas.APIKey)
        if token != expectedToken {
            return echo.NewHTTPError(http.StatusUnauthorized, "Invalid signature")
        }
        
        c.Set("saas", saas)
        return next(c)
    }
}
```

## 案例3：代理关系规范 (agent-rel-spec)

### 3.1 业务场景定义

**文件路径**: `openspec/specs/agent-rel/spec.md`

**实际场景定义**:
```markdown
### Scenario: 商户侧绑定代理——费率校验失败
- **GIVEN** 商户 M（rate=200）通过 chan_merch 关联通道 C（rate=600），已有代理费率合计 300
- **WHEN** 绑定新代理商 A，rate=200
- **THEN** 校验 600 - 200 - 300 - 200 = -100 < 0，拒绝
- **AND THEN** 返回 400 错误，包含各项费率明细

### Scenario: 通道侧修改代理费率——费率校验失败
- **GIVEN** 通道 C（rate=500）下有商户 M1（rate=200）和 M2（rate=300），代理商 A 当前 rate=100
- **WHEN** 修改代理商 A 的费率为 rate=250
- **THEN** 对 M2 的校验 500 - 300 - 250 = -50 < 0，拒绝
- **AND THEN** 返回 400 错误，包含费率明细
```

### 3.2 实际费率校验实现

**费率信息结构体** (`serve/biz/common/rate.go`):
```go
type RateInfo struct {
    E       biz.ChanMerch `json:"e"`  // 连线
    C       biz.Chan      `json:"c"`  // 通道
    M       biz.Merch     `json:"m"`  // 商户
    CAgents []AgentRel    `json:"ca"` // 通道代理
    MAgents []AgentRel    `json:"ma"` // 商户代理
}

// CheckRate 费率计算: 通道费率 - 商户费率 - 代理费率, 返回剩余费率 or 详细的错误信息
func (r *RateInfo) CheckRate() (int64, error) {
    // 获取通道费率
    chanRate := r.C.Rate
    // 获取商户费率
    merchRate := r.M.Rate
    // 计算代理费率总和
    var agentRate int64
    for _, agentRel := range r.CAgents {
        agentRate += agentRel.Rate
    }
    for _, agentRel := range r.MAgents {
        agentRate += agentRel.Rate
    }
    // 计算: 通道费率 - 商户费率 - 代理费率
    result := chanRate - merchRate - agentRate
    // 验证是否 >= 0
    if result < 0 {
        return 0, fmt.Errorf("修改后费率无效: 通道费率 - 商户费率 - 代理费率 < 0\n%s", r.String())
    }
    return result, nil
}
```

### 3.3 绑定操作实现

**代理绑定接口** (`serve/routes/admin/merch/agent/attach.go`):
```go
// 绑定机构商户
func (h *handler) bindAgent(c echo.Context) error {
    type Input struct {
        MerchId uint64 `json:"merch_id,string" validate:"required,min=1"`
        AgentId uint64 `json:"agent_id,string" validate:"required,min=1"`
        Action  string `json:"action" validate:"required,oneof=bound unbound rate"`
        Rate    int64  `json:"rate" validate:"required,min=0,max=100000"`
    }
    
    // ... 参数绑定和验证 ...
    
    switch input.Action {
    case "bound":
        if ok {
            return echo.NewHTTPError(http.StatusBadRequest, "该代理商和商户已绑定")
        }
        
        // TODO: 费率校验被注释掉了！这是一个bug
        // if err := common.CheckRate(input.Rate); err != nil {
        //     return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        // }
        
        var agentRel biz.AgentRel
        agentRel.ID = snowflake.SnowflakeId()
        agentRel.AgentNo = agent.AgentNo
        agentRel.AgentType = "MERCH"
        agentRel.AgentID = agent.ID
        agentRel.ObjID = merch.ID
        agentRel.ObjNo = merch.MerchNo
        agentRel.ObjName = merch.Name
        agentRel.Rate = input.Rate
        err = biz.AgentRelModel.WithSession(session).InsertOne(&agentRel)
        if err != nil {
            return err
        }
    // ... 其他操作 ...
    }
}
```

## 实际经验总结

### 4.1 openspec 的实际价值

1. **问题发现**: 通过分析 `bindAgent` 函数，发现了费率校验被注释掉的严重bug
2. **变更追溯**: 通过 `add-saas-api` 案例，清晰地追踪了认证问题的修复过程
3. **设计验证**: 通过 `agent-profit-settlement` 案例，验证了分润计算的业务逻辑正确性

### 4.2 实施要点

1. **从问题出发**: 每个openspec变更都应该解决具体的问题或需求
2. **场景驱动**: 使用Given/When/Then格式描述具体的业务场景
3. **代码对齐**: 确保文档与实际代码实现保持一致
4. **渐进演进**: 通过小步快跑的方式逐步完善系统功能

### 4.3 常见陷阱

1. **文档与代码脱节**: 如代理绑定中的费率校验被注释掉
2. **忽略向后兼容**: BREAKING变更需要考虑兼容性策略
3. **过度设计**: 应该聚焦解决当前问题，而不是过度抽象

这些实际案例展示了如何在真实的复杂软件项目中有效使用fission-ai/openspec来管理需求、设计和实现。