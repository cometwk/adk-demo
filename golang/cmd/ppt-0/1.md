---
theme: gaia
_class: lead
paginate: true
backgroundColor: #fff
backgroundImage: url('https://marp.app/assets/hero-background.svg')
marp: true
style: |
  .columns2 {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 1rem;

    /* Center align content vertically */
    align-items: center;
  }
---

# OpenSpec TDD 简述

让需求、设计、代码、测试对齐

> 核心思想：  
> **Spec 是唯一真相源（SSOT）**

---

## 什么是 OpenSpec TDD？

- 不是「先写测试」
- 而是 **先写可执行规格（Spec）**

让 `需求、设计、测试、代码` **围绕同一个 Spec 收敛**

**Spec 定义“什么叫对”**

---

## OpenSpec 的三层结构

- 三类文档，三种关注点

| 文档        | 关注点 | 回答的问题                  |
| ----------- | ------ | --------------------------- |
| proposal.md | 需求   | 为什么做（Why）             |
| design.md   | 设计   | 如何做（How）               |
| spec.md     | 规格   | 什么算对（What / Contract） |

- **TDD 的核心在 `spec.md`**

---

## proposal.md（需求层）

<div class="columns2">
<div>

只回答三件事：

- **问题是什么**
- **谁在痛**
- **成功的业务判据是什么**

</div>

<div>

示例（抽象）：
> 用户需要批量导入订单  
> 当前单条导入效率低  
> 成功标准：10k 订单 < 5 秒，失败可追溯

</div>
</div>

<center>

**⚠不写 API / 字段 / 实现**

</center>

---

## design.md（设计层）


<div class="columns2">
<div>

把“意图”变成**结构性决策**：

- 架构选型
- 模块职责
- 关键 trade-off
- 不变量（Invariant）

</div>
<div>

示例：

- 采用异步 pipeline
- 三阶段：parse → validate → persist
- 保证：
    - 同一 order_id 幂等
    - 单条失败不影响整体
</div>
</div>

---

## spec.md（规格层）

### TDD 分水岭

- 不是说明文档
- 是 **可被测试验证的行为契约**

> **Spec = 法律文本  
> 测试 = 执法  
> 代码 = 被约束对象**

---

## Spec 的三种核心范式

### ① 行为范式（Behavior）

```text
Given a valid batch with 3 orders
When import is executed
Then 3 orders MUST be persisted
```

---

### ② 约束范式（Constraint）

```text
- order_id MUST be globally unique
- duplicated order_id MUST NOT create new records
```

---

### ③ 边界 / 失败范式（Edge / Failure）

```text
When one order is invalid
Then:
- valid orders are persisted
- invalid orders are reported
```

**每一句都能映射成测试断言**

---

## Spec → 测试

### 测试只是 Spec 的“翻译器”

| Spec 表达           | 测试代码               |
| ------------------- | ---------------------- |
| Given / When / Then | Arrange / Act / Assert |
| MUST                | assert                 |
| MUST NOT            | assert false           |
| Failure             | 负向测试               |

原则：

- 测试 **不能超出 Spec**
- Spec 变 → 测试必须变

---

## 测试 → 代码

### 代码的唯一目标

- 通过 Spec 定义的测试
- 不多做
- 不少做

> **Spec 里没有的行为  
> = 非法复杂度**

---

## 四者如何对齐

### OpenSpec TDD 闭环

```text
proposal  → 定义业务成功
design    → 定义结构与不变量
spec      → 定义可验证行为
tests     → 验证行为
code      → 满足行为
```

---

## 冲突裁决规则

### 谁说了算？

| 冲突         | 结果        |
| ------------ | ----------- |
| 代码 vs 测试 | 测试赢      |
| 测试 vs Spec | Spec 赢     |
| Spec vs 设计 | Spec 赢     |
| 设计 vs 需求 | proposal 赢 |

**Spec 是最终裁判**

---

## 与传统 TDD 对比

| 传统 TDD     | OpenSpec TDD |
| ------------ | ------------ |
| 测试即需求   | Spec 即需求  |
| 测试难评审   | Spec 可评审  |
| 测试是代码   | Spec 是语言  |
| 易过拟合实现 | 强行为约束   |

---

## 总结（一句话）

> **不是先写测试，  
> 而是先把“什么叫对”说清楚。**

---

## 举例（新主题）

- 业务场景：批量导入订单
- 需求成功：10k 单 < 5 秒，失败可追溯
- Spec 片段：
  - `Given` 合法批次
  - `When` 执行导入
  - `Then` 订单全部落库

---

## 落地细节（新主题）

- 规格先行：先补全 `spec.md`
- 测试翻译：按 Spec 编写断言
- 实现收敛：只为通过 Spec
- 评审重点：Spec 的可验证性

---

## 如何变更

- 先改 Spec，再更新测试与代码
- 变更必须可回溯（Spec 版本/评审记录）
- 发布后回归：用 Spec 驱动验收

---

theme: gaia
\_class: lead
paginate: true
backgroundColor: #fff
backgroundImage: url('https://marp.app/assets/hero-background.svg')
marp: true

---

## Slide 1 · 标题页

### OpenSpec TDD 简述

**如何将需求、设计、代码、测试对齐**

> 核心思想：  
> **用 Spec 作为唯一真相源（SSOT）**

---

## Slide 2 · 一句话结论

### 什么是 OpenSpec TDD？

- 不是「先写测试」
- 而是 **先写可执行规格（Spec）**
- 让：
  - 需求
  - 设计
  - 测试
  - 代码  
     **围绕同一个 Spec 收敛**

> **Spec 定义“什么叫对”**

---

## Slide 3 · OpenSpec 的三层结构

### 三类文档，三种关注点

| 文档        | 关注点 | 回答的问题                  |
| ----------- | ------ | --------------------------- |
| proposal.md | 需求   | 为什么做（Why）             |
| design.md   | 设计   | 如何做（How）               |
| spec.md     | 规格   | 什么算对（What / Contract） |

📌 **TDD 的核心在 spec.md**

---

## Slide 4 · proposal.md（需求层）

### 只回答业务问题

- 问题是什么
- 谁在痛
- 成功的业务判据是什么

示例：

- 当前单条导入效率低
- 需要支持批量导入订单
- 成功标准：
  - 10k 订单 < 5 秒
  - 失败可追溯

⚠️ **不写 API / 字段 / 实现**

---

## Slide 5 · design.md（设计层）

### 将需求转为结构性决策

- 架构选型
- 模块划分
- 不变量（Invariant）
- Trade-off 说明

示例：

- 异步 pipeline
- parse → validate → persist
- 不变量：
  - order_id 幂等
  - 单条失败不影响整体

⚠️ **仍然不写测试、不写代码**

---

## Slide 6 · spec.md（规格层）——TDD 分水岭

### Spec 是什么？

- 不是说明文档
- 是 **可被测试验证的行为契约**

> **Spec = 法律文本  
> 测试 = 执法  
> 代码 = 被约束对象**

---

## Slide 7 · Spec 的三种核心范式

### ① 行为范式（Behavior）

```text
Given a valid batch with 3 orders
When import is executed
Then 3 orders MUST be persisted
```

---

### ② 约束范式（Constraint）

```text
- order_id MUST be globally unique
- duplicated order_id MUST NOT create new records
```

---

### ③ 边界 / 失败范式（Edge / Failure）

```text
When one order is invalid
Then:
- valid orders are persisted
- invalid orders are reported
```

📌 **每一句都能映射成测试断言**

---

## Slide 8 · Spec → 测试

### 测试只是 Spec 的“翻译器”

| Spec 表达           | 测试代码               |
| ------------------- | ---------------------- |
| Given / When / Then | Arrange / Act / Assert |
| MUST                | assert                 |
| MUST NOT            | assert false           |
| Failure             | 负向测试               |

原则：

- 测试 **不能超出 spec**
- spec 变 → 测试必须变

---

## Slide 9 · 测试 → 代码

### 代码的唯一目标

- 通过 Spec 定义的测试
- 不多做
- 不少做

> **Spec 里没有的行为  
> = 非法复杂度**

---

## Slide 10 · 四者如何对齐（核心闭环）

### OpenSpec TDD 闭环

```text
proposal  → 定义业务成功
design    → 定义结构与不变量
spec      → 定义可验证行为
tests     → 验证行为
code      → 满足行为
```

---

## Slide 11 · 冲突裁决规则

### 谁说了算？

| 冲突         | 结果        |
| ------------ | ----------- |
| 代码 vs 测试 | 测试赢      |
| 测试 vs Spec | Spec 赢     |
| Spec vs 设计 | Spec 赢     |
| 设计 vs 需求 | proposal 赢 |

📌 **Spec 是最终裁判**

---

## Slide 12 · 与传统 TDD 对比

| 传统 TDD     | OpenSpec TDD |
| ------------ | ------------ |
| 测试即需求   | Spec 即需求  |
| 测试难评审   | Spec 可评审  |
| 测试是代码   | Spec 是语言  |
| 易过拟合实现 | 强行为约束   |

---

## Slide 13 · 总结页（一句话）

### OpenSpec TDD 的本质

> **不是先写测试，  
> 而是先把“什么叫对”说清楚。**

---

## Slide 14 · 举例（新主题）

## Slide 14 · 落地细节（新主题）

## Slide 14 · 如何变更
