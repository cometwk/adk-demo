# MySQL FAQ（项目踩坑记录）

## 并发去重：1062 冲突后“同事务查询不到已提交行”（REPEATABLE READ 快照）

### 背景
本项目实现“内容去重上传”时，依赖数据库唯一约束保证并发正确性：

- `file_blobs.hash` 有 `UNIQUE` 约束
- 并发上传相同内容时：只有一个请求能插入 blob，其它请求会拿到 **1062 Duplicate entry**，然后“复用已有 blob”

### 现象
在并发测试/压测中，偶发出现：

- 已经收到了 1062 唯一冲突（说明“别的并发请求”已经把该 hash 的 blob 插入了）
- 但随后在同一个 handler 里 `SELECT ... WHERE hash = ?` 却查不到那条 blob
- 最终抛出类似错误：`db dedup failed`

### 根因（前因后果）
MySQL 默认事务隔离级别通常是 **REPEATABLE READ（RR）**。

- RR 的核心语义：**同一个事务内，多次读取同一条件的结果应保持一致**（读到的是事务开始时刻的快照）
- 因此当你的代码在一个显式事务里：
  - 先 `BEGIN`
  - 尝试 `INSERT file_blobs(hash=...)`
  - 发生 1062（因为另一个并发事务已经插入并提交）
  - 你在**同一个事务**里再去 `SELECT ... WHERE hash=?`
- 这次 `SELECT` 可能仍然基于该事务的快照，**看不到另一个事务在你 BEGIN 之后提交的新行**，从而出现“明明 1062 了但却查不到行”的矛盾现象。

换句话说：**1062 是在写入路径上碰到了“当前最新提交状态”，但你随后的读取仍被 RR 的一致性读快照限制**。

### 解决方案（推荐）
避免把“去重兜底的重查”放在同一个长事务快照里：

- **方案 A（推荐）**：blob 的插入/查询不要包在显式事务里（或至少不要在事务开始后做“冲突后重查”）
  - 先查（无事务 / autocommit）
  - 不存在则插入（可能 1062）
  - 发生 1062 后**再查一次**（无事务 / autocommit），保证读到最新已提交行
- **方案 B**：发生 1062 后，用**新的 session/新的事务**去查询（确保快照更新）

### 本项目落地
在 `serve/s3/localfs.go` 的上传逻辑里，我们将采用方案 A：

- `file_blobs` 的 “insert + 1062 recovery + re-select” **移出显式事务**
- 确保 1062 后的 `SELECT` 能读到已提交行，从而稳定复用 blob，避免 `db dedup failed`

